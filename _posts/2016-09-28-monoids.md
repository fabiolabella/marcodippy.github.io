---
layout: post
published: false
title: Monoids
tags:
  - functional-programming
  - monoids
  - scala
date: '2016-09-28'
subtitle: >-
  _Monoid_... I love the way this word sounds, so this definitely must be the
  topic for my new blog post.
---
> _The path of the functional programmer is beset on all sides by the inequities of the selfish and the tyranny of Category Theory.
Blessed is he, who in the name of charity and good will, shepherds the weak through the valley of darkness,  for he is truly his brother's keeper and the finder of lost children.
And I will strike down upon thee with great vengeance and furious anger those who would attempt to poison and destroy my brothers by talking about_ **Morphisms**, **Arrows**, **Categories** _and other_ **confusing things with funny names**_._

A lot of FP concepts bear a scary name like _Functor_ or _Monad_ coming from category theory (subject I know ___nothing___ about), but despite their names some of those concepts are fairly easy to grasp. One of the easiest is called **monoid**.

In few words, monoid are abstraction over things that can be _“aggregated/summed up”_ with an associative binary operation. That's all. 

More formally, a monoid is a **set of objects** plus an **operation** to combine those objects that must obey the following laws:

* *Closure Law*: the result of the _operation_ must be an element of the input set; given _(a, b) ∈ S_  and _operation(a, b) = x then x ∈ S_.
* Associative Law: (a _op_ b) _op_ c == a _op_ (b _op_ c).
* Identity Element: the _operation_ must have an element (also called _zero_) that "does nothing": zero _op_ a == a and a _op_ zero == a (these are called, respectively, _left identity_ and _right identity_

To make it event more crystal clear, here are some examples:


